// Generated by CoffeeScript 1.6.2
/*

  Recreate streams on end and/or error
*/

var backoff, through;

through = require('through');

backoff = require('backoff');

module.exports = function(makeStream, options) {
  var cleanup, connectedEvent, log, origEnd, passData, stream;

  if (options == null) {
    options = {};
  }
  if (options === void 0 && makeStream.toString() === '[object Object]') {
    options = makeStream;
    makeStream = options.makeStream;
  }
  if (options.connect === void 0) {
    options.connect = true;
  }
  connectedEvent = options.connectedEvent || 'open';
  log = function(msg) {
    if (options.log === null) {
      return;
    }
    if (options.log) {
      return options.log(msg);
    } else {
      return console.log(msg);
    }
  };
  cleanup = function() {
    return stream.underlying.removeListener('data', passData);
  };
  passData = function(chunk) {
    console.log('i:', chunk);
    return stream._data(chunk);
  };
  stream = through();
  stream.inverse = through();
  stream.inverse.pause();
  stream.write = function(chunk) {
    return stream.inverse.write(chunk);
  };
  stream.backoff = options.backoff || backoff.exponential(options);
  stream.backoff.on('backoff', function(num, delay) {
    return log("next connection attempt in " + delay + "ms");
  });
  stream.backoff.on('ready', function() {
    log("trying to re-establish connection");
    return stream.connect();
  });
  stream.backoff.on('fail', function() {
    return log("out of attempts to re-establish connection");
  });
  stream.connect = function() {
    stream.underlying = makeStream();
    stream.inverse.pipe(stream.underlying, {
      end: false
    });
    stream.underlying.on('data', function(chunk) {
      return stream.emit('data', chunk);
    });
    stream.underlying.on(connectedEvent, function() {
      log("connection established");
      stream.backoff.reset();
      stream.inverse.resume();
      return stream.emit('open');
    });
    stream.underlying.on('end', function() {
      log("connection terminated");
      stream.inverse.pause();
      cleanup();
      if (!stream.preventBackoff) {
        return stream.backoff.backoff();
      }
    });
    return stream.underlying.on('error', function(e) {
      log("error " + e);
      stream.inverse.pause();
      cleanup();
      if (!stream.preventBackoff) {
        return stream.backoff.backoff();
      }
    });
  };
  origEnd = stream.end.bind(stream);
  stream.end = function() {
    stream.preventBackoff = true;
    stream.underlying.end();
    return origEnd();
  };
  if (options.connect) {
    stream.connect();
  }
  return stream;
};
